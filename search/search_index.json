{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pydongo","text":"<p>Pydongo is a lightweight and expressive ORM for MongoDB powered by Pydantic.</p> <p>It brings structure and type safety to your unstructured NoSQL world \u2014 giving you clean, Pythonic control over your MongoDB documents.</p>"},{"location":"#why-use-pydongo","title":"\ud83d\ude80 Why Use Pydongo?","text":"<ul> <li>\u2705 Pydantic-first: Write your models as <code>BaseModel</code> classes \u2014 just like you're used to</li> <li>\ud83d\udd04 Sync + Async support via <code>pymongo</code> and <code>motor</code></li> <li>\ud83e\udde0 Elegant Query DSL: Express Mongo filters using <code>==</code>, <code>&gt;</code>, <code>&amp;</code>, <code>|</code> and more</li> <li>\ud83e\uddea Built for Testing: In-memory mock driver makes unit testing easy</li> <li>\ud83e\uddf0 No boilerplate: Automatically connects models to collections</li> <li>\ud83d\udce6 Tiny but powerful: Focused API, zero clutter</li> </ul>"},{"location":"#example","title":"\ud83e\uddf1 Example","text":"<pre><code>from pydantic import BaseModel\nfrom pydongo import as_document, as_collection\nfrom pydongo.drivers.sync_mongo import DefaultMongoDBDriver\n\nclass User(BaseModel):\n    name: str\n    age: int\n\ndriver = DefaultMongoDBDriver(\"mongodb://localhost:27017\", \"mydb\")\ndriver.connect()\n\n# Insert a document\ndoc = as_document(User(name=\"Alice\", age=30), driver)\ndoc.save()\n\n# Query with expressive DSL\ncollection = as_collection(User, driver)\nresults = collection.find(collection.age &gt; 25).all()\n\nfor user in results:\n    print(user.name, user.age)\n\ndriver.close()\n</code></pre>"},{"location":"#learn-more","title":"\ud83d\udcda Learn More","text":"<ul> <li>Installation</li> <li>Quickstart</li> </ul>"},{"location":"#get-involved","title":"\ud83d\udcac Get Involved","text":"<p>Contributions welcome! Check out the contributing guide or open an issue on GitHub.</p>"},{"location":"#license","title":"\ud83e\uddfe License","text":"<p>Pydongo is open source under the MIT License.</p>"},{"location":"collections/","title":"Working with Collections","text":"<p>The <code>CollectionWorker</code> and its response builders provide a powerful yet intuitive API to query, filter, and iterate over documents in a MongoDB collection \u2014 all while keeping your data model as a clean Pydantic class.</p>"},{"location":"collections/#creating-a-collection-interface","title":"\ud83d\udce5 Creating a Collection Interface","text":"<p>You don't interact directly with <code>CollectionWorker</code>. Instead, use the <code>as_collection()</code> helper:</p> <pre><code>from pydongo import as_collection\nfrom pydantic import BaseModel\nfrom pydongo.drivers.sync_mongo import DefaultMongoDBDriver\n\nclass User(BaseModel):\n    name: str\n    age: int\n\ndriver = DefaultMongoDBDriver(\"mongodb://localhost:27017\", \"mydb\")\ndriver.connect()\n\ncollection = as_collection(User, driver)\n</code></pre> <p>By default, the collection name is inferred from the model class (<code>User</code> \u2192 <code>\"user\"</code>).</p>"},{"location":"collections/#finding-documents","title":"\ud83d\udd0d Finding Documents","text":""},{"location":"collections/#find_one-sync","title":"<code>.find_one()</code> (Sync)","text":"<pre><code>user = collection.find_one(collection.name == \"Alice\")\nif user:\n    print(user.pydantic_object.name)\n</code></pre>"},{"location":"collections/#await-afind_one-async","title":"<code>await afind_one()</code> (Async)","text":"<pre><code>user = await collection.afind_one(collection.age &gt; 25)\nif user:\n    print(user.pydantic_object.age)\n</code></pre>"},{"location":"collections/#fluent-query-builder-find","title":"\ud83d\udd01 Fluent Query Builder (<code>.find()</code>)","text":"<p>For multiple documents and advanced queries, use <code>.find()</code> to build a query:</p> <pre><code>results = collection.find(collection.age &gt; 20).sort(collection.name).limit(5).all()\n\nfor user in results:\n    print(user.name, user.age)\n</code></pre> <p>Async version:</p> <pre><code>results = await collection.find(collection.age &gt; 20).sort(-collection.age).limit(10).all()\n\nfor user in results:\n    print(user.name, user.age)\n</code></pre>"},{"location":"collections/#other-query-builder-features","title":"\u2728 Other Query Builder Features","text":"Method Description <code>.find(expr)</code> Filter query <code>.sort(field)</code> Sort by one or more fields <code>.limit(n)</code> Limit results <code>.skip(n)</code> Offset results <code>.all()</code> / <code>await .all()</code> Fetch all documents <code>.count()</code> / <code>await .count()</code> Count matching documents <code>.exists()</code> / <code>await .exists()</code> Check if any document exists"},{"location":"collections/#notes","title":"\ud83e\udde0 Notes","text":"<ul> <li>All results returned from <code>.find()</code> and <code>.find_one()</code> are wrapped in <code>DocumentWorker</code> or <code>AsyncDocumentWorker</code></li> <li>You can use <code>doc.pydantic_object</code> to access or mutate the model</li> <li>The query language supports <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&amp;</code>, <code>|</code>, and <code>~</code></li> </ul>"},{"location":"collections/#example-combining-filters","title":"\u2705 Example: Combining Filters","text":"<pre><code>query = (collection.age &gt; 18) &amp; (collection.name != \"Bob\")\nresults = collection.find(query).all()\n\nfor user in results:\n    print(user.name)\n</code></pre> <p>Or async:</p> <pre><code>query = (collection.age &gt; 18) &amp; (collection.name != \"Bob\")\nresults = await collection.find(query).all()\n\nfor user in results:\n    print(user.name)\n</code></pre>"},{"location":"collections/#summary","title":"\u2705 Summary","text":"<ul> <li>Use <code>as_collection()</code> to query a MongoDB collection</li> <li>Works for both sync and async workflows</li> <li>Returns <code>DocumentWorker</code>/<code>AsyncDocumentWorker</code> instances</li> <li>Supports fluent chaining and expressive filter logic</li> </ul> <p>Pydongo gives you clean Mongo-style querying with the structure of Pydantic \u2014 no inheritance, no decorators, just Python.</p>"},{"location":"documents/","title":"Working with Documents","text":"<p>The <code>DocumentWorker</code> class in Pydongo provides a convenient interface to perform CRUD operations on a single document, while preserving your original Pydantic model structure.</p> <p>This is one of the core patterns of Pydongo \u2014 it enables persistence without requiring your models to inherit from any base class.</p>"},{"location":"documents/#how-it-works","title":"\ud83e\uddf1 How It Works","text":"<p>To work with a document, you wrap a Pydantic model using <code>as_document()</code>:</p> <pre><code>from pydantic import BaseModel\nfrom pydongo import as_document\nfrom pydongo.drivers.sync_mongo import DefaultMongoDBDriver\n\nclass User(BaseModel):\n    name: str\n    age: int\n\ndriver = DefaultMongoDBDriver(\"mongodb://localhost:27017\", \"mydb\")\ndriver.connect()\n\nuser = User(name=\"Alice\", age=30)\ndoc = as_document(user, driver)\n\ndoc.save()  # inserts into the 'user' collection\n</code></pre> <p>By default, Pydongo will infer the collection name from the model class name (<code>User</code> \u2192 <code>\"user\"</code>).</p>"},{"location":"documents/#supported-operations","title":"\u2705 Supported Operations","text":""},{"location":"documents/#save","title":"<code>.save()</code>","text":"<ul> <li>If the document does not exist in the database, it will be inserted</li> <li>If it already exists (i.e. <code>objectId</code> is set), it will be updated</li> </ul> <pre><code>doc.pydantic_object.age = 31\ndoc.save()  # Updates the document\n</code></pre>"},{"location":"documents/#delete","title":"<code>.delete()</code>","text":"<ul> <li>Deletes the document from the database based on <code>objectId</code></li> </ul> <pre><code>doc.delete()\n</code></pre>"},{"location":"documents/#accessing-data-from-the-document","title":"\ud83d\udd01 Accessing Data from the Document","text":"<p>Every <code>DocumentWorker</code> exposes the original Pydantic model via <code>.pydantic_object</code>:</p> <pre><code>assert isinstance(doc.pydantic_object, User)\nprint(doc.pydantic_object.name)\n</code></pre> <p>This is useful when you need to: - re-serialize the model (<code>.model_dump()</code>) - re-validate or transform the data - pass the object to other parts of your app</p>"},{"location":"documents/#field-access-shortcut","title":"\ud83e\uddfe Field Access Shortcut","text":"<p>You can also directly access read-only fields of the underlying model:</p> <pre><code>print(doc.name, doc.age)\nassert isinstance(doc.name, str)\n</code></pre> <p>This is purely for convenience and read-only access. To mutate data, modify <code>doc.pydantic_object</code> directly:</p> <pre><code>doc.pydantic_object.age += 1\ndoc.save()\n</code></pre>"},{"location":"documents/#summary","title":"\u2705 Summary","text":"Method Description <code>.save()</code> Insert or update the document <code>.delete()</code> Remove from database <code>.pydantic_object</code> Access the underlying Pydantic model"},{"location":"documents/#the-documentworker-is-a-clean-abstraction-for-managing-the-lifecycle-of-a-single-document-designed-for-devs-who-prefer-explicit-control-and-clean-models","title":"The <code>DocumentWorker</code> is a clean abstraction for managing the lifecycle of a single document \u2014 designed for devs who prefer explicit control and clean models.","text":""},{"location":"documents/#using-asyncdocumentworker","title":"\ud83c\udf10 Using AsyncDocumentWorker","text":"<p>Pydongo also supports asynchronous workflows using <code>AsyncDocumentWorker</code>, which behaves similarly to the sync version but with <code>async</code> methods.</p> <p>You don\u2019t need to construct it manually \u2014 Pydongo will automatically return an <code>AsyncDocumentWorker</code> when used with an async driver:</p> <pre><code>from pydantic import BaseModel\nfrom pydongo import as_document\nfrom pydongo.drivers.async_mongo import DefaultAsyncMongoDBDriver\n\nclass User(BaseModel):\n    name: str\n    age: int\n\ndriver = DefaultAsyncMongoDBDriver(\"mongodb://localhost:27017\", \"mydb\")\nawait driver.connect()\n\nuser = User(name=\"Bob\", age=28)\ndoc = as_document(user, driver)\n\nawait doc.save()  # Insert\nawait doc.delete()  # Delete\n</code></pre>"},{"location":"documents/#key-differences","title":"Key differences:","text":"<ul> <li>Methods like <code>.save()</code> and <code>.delete()</code> are <code>async</code></li> <li>Can be used inside <code>FastAPI</code>, <code>asyncio</code>, and other async frameworks</li> <li>You access <code>.pydantic_object</code> and read-only fields the same way as the sync version</li> </ul> <pre><code>print(doc.name, doc.age)\ndoc.pydantic_object.age += 1\nawait doc.save()\n</code></pre>"},{"location":"documents/#summary-async","title":"\u2705 Summary (Async)","text":"Method Description <code>await .save()</code> Insert or update the document <code>await .delete()</code> Remove from database <code>.pydantic_object</code> Access the underlying Pydantic model <p>The <code>AsyncDocumentWorker</code> is your go-to for async MongoDB workflows \u2014 with the same structure and ergonomics as the sync API.</p>"},{"location":"drivers/","title":"Drivers &amp; Extensibility","text":"<p>Pydongo is built on a pluggable driver interface, allowing you to work with MongoDB in both synchronous and asynchronous contexts \u2014 or even create your own custom drivers (e.g., in-memory mocks, logging wrappers, or remote API-backed data stores).</p>"},{"location":"drivers/#driver-design-philosophy","title":"\ud83d\udd0c Driver Design Philosophy","text":"<p>Drivers are thin layers responsible for executing actual MongoDB operations. They expose a common interface so the higher-level Pydongo logic (documents, queries, filters) remains independent of the connection style.</p> <p>You can choose between:</p> <ul> <li>\u2705 <code>DefaultMongoDBDriver</code> (sync) \u2014 wraps PyMongo</li> <li>\u2705 <code>DefaultAsyncMongoDBDriver</code> (async) \u2014 wraps Motor</li> <li>\u2705 <code>MockMongoDBDriver</code> \u2014 in-memory fake for testing</li> <li>\u2705 Or build your own</li> </ul>"},{"location":"drivers/#abstract-base-classes","title":"\ud83e\uddf1 Abstract Base Classes","text":"<p>All drivers ultimately inherit from <code>AbstractMongoDBDriver</code>.</p> <p>There are two concrete base interfaces:</p>"},{"location":"drivers/#abstractsyncmongodbdriver","title":"<code>AbstractSyncMongoDBDriver</code>","text":"<pre><code>class AbstractSyncMongoDBDriver:\n    def connect(self) -&gt; bool: ...\n    def close(self) -&gt; None: ...\n    def insert_one(self, collection: str, document: dict) -&gt; dict: ...\n    def insert_many(self, collection: str, documents: list[dict]) -&gt; dict: ...\n    def find_one(self, collection: str, query: dict) -&gt; dict | None: ...\n    def find_many(self, collection: str, query: dict, sort_criteria: dict, offset: int, limit: int) -&gt; Iterable[dict]: ...\n    def update_one(self, collection: str, query: dict, update: dict, upsert: bool = False) -&gt; dict: ...\n    def delete_one(self, collection: str, query: dict) -&gt; dict: ...\n    def count(self, collection: str, query: dict) -&gt; int: ...\n    def exists(self, collection: str, query: dict) -&gt; bool: ...\n</code></pre> <p>Each method mirrors a common MongoDB operation and accepts raw query/filter dictionaries.</p>"},{"location":"drivers/#abstractasyncmongodbdriver","title":"<code>AbstractAsyncMongoDBDriver</code>","text":"<p>Same as above, but all methods are <code>async def</code>. Ideal for async frameworks like FastAPI or Quart.</p>"},{"location":"drivers/#default-drivers","title":"\u2705 Default Drivers","text":"<p>Pydongo includes two ready-to-use drivers:</p>"},{"location":"drivers/#defaultmongodbdriver-synchronous","title":"<code>DefaultMongoDBDriver</code> (Synchronous)","text":"<pre><code>from pydongo.drivers.sync_mongo import DefaultMongoDBDriver\n\ndriver = DefaultMongoDBDriver(\"mongodb://localhost:27017\", \"mydb\")\ndriver.connect()\n</code></pre> <p>This driver uses PyMongo internally and is safe for CLI apps, scripts, and synchronous APIs.</p>"},{"location":"drivers/#defaultasyncmongodbdriver-asynchronous","title":"<code>DefaultAsyncMongoDBDriver</code> (Asynchronous)","text":"<pre><code>from pydongo.drivers.async_mongo import DefaultAsyncMongoDBDriver\n\ndriver = DefaultAsyncMongoDBDriver(\"mongodb://localhost:27017\", \"mydb\")\nawait driver.connect()\n</code></pre> <p>This driver wraps Motor and is ideal for async web servers like FastAPI.</p>"},{"location":"drivers/#mock-driver-for-testing","title":"\ud83e\uddea Mock Driver for Testing","text":"<p>Use <code>MockMongoDBDriver</code> or <code>MockAsyncMongoDBDriver</code> to test logic without a real MongoDB instance.</p> <pre><code>from pydongo.drivers.mock import MockMongoDBDriver\n\ndriver = MockMongoDBDriver()\ndriver.connect()\n</code></pre> <p>Useful for unit testing business logic or running Pydongo in CI pipelines.</p>"},{"location":"drivers/#building-a-custom-driver","title":"\ud83e\udde9 Building a Custom Driver","text":"<p>To plug in a custom database backend, subclass one of the abstract driver classes and implement the required methods.</p> <p>Example:</p> <pre><code>from pydongo.drivers.base import AbstractSyncMongoDBDriver\n\nclass LoggingDriver(AbstractSyncMongoDBDriver):\n    def connect(self) -&gt; bool:\n        print(\"Connecting to dummy backend...\")\n        return True\n    def insert_one(self, collection, doc):\n        print(f\"Inserting into {collection}:\", doc)\n        return {\"inserted_id\": \"fake_id\"}\n    # implement other methods...\n</code></pre> <p>Then use with: <pre><code>driver = LoggingDriver()\ndriver.connect()\n</code></pre></p>"},{"location":"drivers/#notes-on-design","title":"\ud83e\udde0 Notes on Design","text":"<ul> <li>Drivers must implement all abstract methods</li> <li>Sync and Async drivers have separate base classes</li> <li>Use <code>driver.connect()</code> and <code>driver.close()</code> in your app lifecycle</li> <li>Avoid mixing sync and async in the same flow</li> </ul>"},{"location":"drivers/#summary","title":"\u2705 Summary","text":"Driver Type Backed By Use Case <code>DefaultMongoDBDriver</code> Sync PyMongo Scripts, CLIs <code>DefaultAsyncMongoDBDriver</code> Async Motor FastAPI, async APIs <code>MockMongoDBDriver</code> Sync In-memory Unit tests <code>MockAsyncMongoDBDriver</code> Async In-memory Async unit tests Custom driver Sync/Async Anything Extend, log, simulate, swap DBs <p>Pydongo keeps your application logic flexible and decoupled from the transport layer \u2014 exactly how clean MongoDB should feel.</p>"},{"location":"dsl-querying/","title":"Using the Query DSL","text":"<p>Pydongo's query engine is built on top of Python-native expressions, making MongoDB queries feel natural and type-safe using your Pydantic models.</p> <p>This page covers how to use <code>FieldExpression</code> and <code>CollectionFilterExpression</code> to write expressive, composable queries \u2014 without writing raw MongoDB dictionaries.</p>"},{"location":"dsl-querying/#field-expressions","title":"\ud83d\udcd0 Field Expressions","text":"<p>Every field on your model becomes a <code>FieldExpression</code> in a collection:</p> <pre><code>collection = as_collection(User, driver)\ncollection.age  # FieldExpression\n</code></pre> <p>This enables query expressions like:</p> <pre><code>collection.age &gt; 25\ncollection.name == \"Alice\"\ncollection.age &lt;= 60\n</code></pre> <p>You can use these in <code>.find()</code> or <code>.find_one()</code>:</p> <pre><code>collection.find(collection.age &gt; 30)\ncollection.find_one((collection.age &gt; 20) &amp; (collection.name != \"Bob\"))\n</code></pre>"},{"location":"dsl-querying/#logical-composition","title":"\ud83d\udd01 Logical Composition","text":"<p>All field expressions produce a <code>CollectionFilterExpression</code>, which can be composed:</p> Operator Description <code>&amp;</code> Logical AND <code>|</code> Logical OR <code>~</code> Logical NOT <pre><code>expr = (collection.age &gt; 18) &amp; (collection.name != \"Bob\")\ncollection.find(expr)\n</code></pre>"},{"location":"dsl-querying/#array-field-expressions","title":"\ud83d\udccc Array Field Expressions","text":"<p>Array fields get additional operators via <code>ArrayFieldExpression</code>.</p> <pre><code>class User(BaseModel):\n    name: str\n    tags: List[str]\n\ncollection = as_collection(User, driver)\ncollection.tags.contains(\"admin\")\ncollection.tags.excludes(\"guest\")\ncollection.tags.matches([\"admin\", \"moderator\"])\ncollection.tags.size() &gt; 2\n</code></pre> <p>Supported: - <code>contains(value)</code> \u2192 <code>$in</code> - <code>excludes(value)</code> \u2192 <code>$nin</code> - <code>matches(list)</code> \u2192 <code>$all</code> or exact match - <code>size() &gt; 2</code> \u2192 <code>$expr: {$gt: [{$size: \"$tags\"}, 2]}</code></p>"},{"location":"dsl-querying/#nested-fields","title":"\u2699\ufe0f Nested Fields","text":"<p>You can access subfields using dot notation automatically:</p> <pre><code>class Address(BaseModel):\n    city: str\n\nclass User(BaseModel):\n    name: str\n    address: Address\n\ncollection = as_collection(User, driver)\ncollection.address.city == \"Lagos\"\n</code></pre> <p>This will generate: <pre><code>{\"address.city\": {\"$eq\": \"Lagos\"}}\n</code></pre></p>"},{"location":"dsl-querying/#serialization","title":"\ud83d\udce4 Serialization","text":"<p>All expressions can be turned into MongoDB queries via <code>.serialize()</code>:</p> <pre><code>expr = (collection.age &gt; 18) &amp; (collection.name == \"Alice\")\nquery = expr.serialize()\n# { \"$and\": [{\"age\": {\"$gt\": 18}}, {\"name\": {\"$eq\": \"Alice\"}}] }\n</code></pre>"},{"location":"dsl-querying/#summary","title":"\u2705 Summary","text":"<ul> <li>Use Python syntax for building MongoDB queries</li> <li>Supports scalar fields, arrays, and nested structures</li> <li>Output is always a valid MongoDB filter object</li> <li>Integrates seamlessly with <code>collection.find()</code>, <code>find_one()</code>, and <code>.count()</code></li> </ul> <p>Pydongo\u2019s DSL gives you clean, powerful Mongo filters \u2014 without ever writing a manual <code>$and</code>, <code>$gt</code>, or <code>$in</code>.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#installation","title":"Installation","text":"<p>Install from PyPI:</p> <pre><code>pip install pydongo\n</code></pre> <p>Or with Poetry:</p> <pre><code>poetry add pydongo\n</code></pre>"},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.9+</li> <li><code>pymongo</code> (auto-installed)</li> <li><code>motor</code> (for async support)</li> </ul>"},{"location":"quickstart/","title":"Quickstart","text":""},{"location":"quickstart/#quickstart","title":"Quickstart","text":"<p>This guide walks you through creating and interacting with MongoDB documents using <code>Pydongo</code> \u2014 covering both Document and Collection workers.</p>"},{"location":"quickstart/#step-1-define-a-pydantic-model","title":"\ud83e\uddf1 Step 1: Define a Pydantic Model","text":"<pre><code>from pydantic import BaseModel\n\nclass User(BaseModel):\n    name: str\n    age: int\n</code></pre>"},{"location":"quickstart/#step-2-connect-to-mongodb","title":"\ud83d\udd0c Step 2: Connect to MongoDB","text":"<pre><code>from pydongo.drivers.sync_mongo import DefaultMongoDBDriver\n\ndriver = DefaultMongoDBDriver(\"mongodb://localhost:27017\", \"mydb\")\ndriver.connect()\n</code></pre>"},{"location":"quickstart/#step-3-use-the-document-worker-create-update-delete","title":"\ud83d\udcc4 Step 3: Use the Document Worker (create, update, delete)","text":"<pre><code>from pydongo import as_document\n\n# Create and save a new user\nuser = User(name=\"Alice\", age=30)\ndoc = as_document(user, driver)\ndoc.save()\n\n# Update user and save again\ndoc.age = 31\ndoc.save()\n\n# Delete user\ndoc.delete()\n</code></pre>"},{"location":"quickstart/#step-4-use-the-collection-worker-query-read","title":"\ud83d\udce6 Step 4: Use the Collection Worker (query, read)","text":"<pre><code>from pydongo import as_collection\n\ncollection = as_collection(User, driver)\n\n# Insert multiple users\nusers = [\n    User(name=\"Bob\", age=25),\n    User(name=\"Charlie\", age=35),\n    User(name=\"Diana\", age=40),\n]\nfor user in users:\n    as_document(user, driver).save()\n\n# Query users older than 30\nresults = collection.find(collection.age &gt; 30).all()\nfor result in results:\n    print(f\"{result.name} - {result.age}\")\n\n# Find one\nbob = collection.find_one(collection.name == \"Bob\")\nif bob:\n    print(\"Found Bob:\", bob.age)\n\n# Delete via result\nif bob:\n    bob.delete()\n</code></pre>"},{"location":"quickstart/#step-5-close-the-driver","title":"\u2705 Step 5: Close the driver","text":"<pre><code>driver.close()\n</code></pre> <p>This covers basic CRUD using: - <code>as_document()</code> for direct document operations - <code>as_collection()</code> for querying multiple documents</p> <p>Now you're ready to model complex documents, build queries, and wrap async flows too.</p>"}]}